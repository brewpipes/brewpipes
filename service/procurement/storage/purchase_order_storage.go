package storage

import (
	"context"
	"errors"
	"fmt"
	"time"

	"github.com/brewpipes/brewpipes/service"
	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgconn"
)

func (c *Client) CreatePurchaseOrder(ctx context.Context, order PurchaseOrder) (PurchaseOrder, error) {
	autoGenerated := false
	if order.OrderNumber == "" {
		autoGenerated = true
	}

	for attempt := 0; attempt < 5; attempt++ {
		if autoGenerated {
			orderNumber, err := c.nextPurchaseOrderNumber(ctx, time.Now().UTC())
			if err != nil {
				return PurchaseOrder{}, fmt.Errorf("creating purchase order: %w", err)
			}
			order.OrderNumber = orderNumber
		}

		err := c.db.QueryRow(ctx, `
			INSERT INTO purchase_order (
				supplier_id,
				order_number,
				status,
				ordered_at,
				expected_at,
				notes
			) VALUES ($1, $2, $3, $4, $5, $6)
			RETURNING id, uuid, supplier_id, order_number, status, ordered_at, expected_at, notes, created_at, updated_at, deleted_at`,
			order.SupplierID,
			order.OrderNumber,
			order.Status,
			order.OrderedAt,
			order.ExpectedAt,
			order.Notes,
		).Scan(
			&order.ID,
			&order.UUID,
			&order.SupplierID,
			&order.OrderNumber,
			&order.Status,
			&order.OrderedAt,
			&order.ExpectedAt,
			&order.Notes,
			&order.CreatedAt,
			&order.UpdatedAt,
			&order.DeletedAt,
		)
		if err == nil {
			// Resolve supplier UUID
			var supplierUUID string
			sErr := c.db.QueryRow(ctx, `SELECT uuid FROM supplier WHERE id = $1`, order.SupplierID).Scan(&supplierUUID)
			if sErr == nil {
				order.SupplierUUID = &supplierUUID
			}
			return order, nil
		}

		if autoGenerated {
			var pgErr *pgconn.PgError
			if errors.As(err, &pgErr) && pgErr.Code == "23505" {
				if pgErr.ConstraintName == "purchase_order_order_number_idx" || pgErr.ConstraintName == "purchase_order_order_number_key" {
					order.OrderNumber = ""
					continue
				}
			}
		}

		return PurchaseOrder{}, fmt.Errorf("creating purchase order: %w", err)
	}

	return PurchaseOrder{}, fmt.Errorf("creating purchase order: could not generate unique order number")
}

func (c *Client) UpdatePurchaseOrder(ctx context.Context, id int64, update PurchaseOrderUpdate) (PurchaseOrder, error) {
	var order PurchaseOrder
	err := c.db.QueryRow(ctx, `
		UPDATE purchase_order
		SET
			order_number = COALESCE($1, order_number),
			status = COALESCE($2, status),
			ordered_at = COALESCE($3, ordered_at),
			expected_at = COALESCE($4, expected_at),
			notes = COALESCE($5, notes),
			updated_at = timezone('utc', now())
		WHERE id = $6 AND deleted_at IS NULL
		RETURNING id, uuid, supplier_id, order_number, status, ordered_at, expected_at, notes, created_at, updated_at, deleted_at`,
		update.OrderNumber,
		update.Status,
		update.OrderedAt,
		update.ExpectedAt,
		update.Notes,
		id,
	).Scan(
		&order.ID,
		&order.UUID,
		&order.SupplierID,
		&order.OrderNumber,
		&order.Status,
		&order.OrderedAt,
		&order.ExpectedAt,
		&order.Notes,
		&order.CreatedAt,
		&order.UpdatedAt,
		&order.DeletedAt,
	)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return PurchaseOrder{}, service.ErrNotFound
		}
		return PurchaseOrder{}, fmt.Errorf("updating purchase order: %w", err)
	}

	// Resolve supplier UUID
	var supplierUUID string
	sErr := c.db.QueryRow(ctx, `SELECT uuid FROM supplier WHERE id = $1`, order.SupplierID).Scan(&supplierUUID)
	if sErr == nil {
		order.SupplierUUID = &supplierUUID
	}

	return order, nil
}

func (c *Client) UpdatePurchaseOrderByUUID(ctx context.Context, orderUUID string, update PurchaseOrderUpdate) (PurchaseOrder, error) {
	var order PurchaseOrder
	err := c.db.QueryRow(ctx, `
		UPDATE purchase_order
		SET
			order_number = COALESCE($1, order_number),
			status = COALESCE($2, status),
			ordered_at = COALESCE($3, ordered_at),
			expected_at = COALESCE($4, expected_at),
			notes = COALESCE($5, notes),
			updated_at = timezone('utc', now())
		WHERE uuid = $6 AND deleted_at IS NULL
		RETURNING id, uuid, supplier_id, order_number, status, ordered_at, expected_at, notes, created_at, updated_at, deleted_at`,
		update.OrderNumber,
		update.Status,
		update.OrderedAt,
		update.ExpectedAt,
		update.Notes,
		orderUUID,
	).Scan(
		&order.ID,
		&order.UUID,
		&order.SupplierID,
		&order.OrderNumber,
		&order.Status,
		&order.OrderedAt,
		&order.ExpectedAt,
		&order.Notes,
		&order.CreatedAt,
		&order.UpdatedAt,
		&order.DeletedAt,
	)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return PurchaseOrder{}, service.ErrNotFound
		}
		return PurchaseOrder{}, fmt.Errorf("updating purchase order by uuid: %w", err)
	}

	// Resolve supplier UUID
	var supplierUUID string
	sErr := c.db.QueryRow(ctx, `SELECT uuid FROM supplier WHERE id = $1`, order.SupplierID).Scan(&supplierUUID)
	if sErr == nil {
		order.SupplierUUID = &supplierUUID
	}

	return order, nil
}

func (c *Client) nextPurchaseOrderNumber(ctx context.Context, now time.Time) (string, error) {
	prefix := now.Format("20060102")
	pattern := fmt.Sprintf("^%s[0-9]{3}$", prefix)
	var maxSuffix int
	err := c.db.QueryRow(ctx, `
		SELECT COALESCE(MAX(CAST(SUBSTRING(order_number FROM 9 FOR 3) AS int)), 0)
		FROM purchase_order
		WHERE order_number LIKE $1 AND order_number ~ $2`,
		prefix+"%",
		pattern,
	).Scan(&maxSuffix)
	if err != nil {
		return "", fmt.Errorf("selecting purchase order sequence: %w", err)
	}
	if maxSuffix >= 999 {
		return "", fmt.Errorf("purchase order sequence exhausted for %s", prefix)
	}

	return fmt.Sprintf("%s%03d", prefix, maxSuffix+1), nil
}

func (c *Client) GetPurchaseOrder(ctx context.Context, id int64) (PurchaseOrder, error) {
	var order PurchaseOrder
	err := c.db.QueryRow(ctx, `
		SELECT po.id, po.uuid, po.supplier_id, s.uuid, po.order_number, po.status, po.ordered_at, po.expected_at, po.notes, po.created_at, po.updated_at, po.deleted_at
		FROM purchase_order po
		JOIN supplier s ON s.id = po.supplier_id
		WHERE po.id = $1 AND po.deleted_at IS NULL`,
		id,
	).Scan(
		&order.ID,
		&order.UUID,
		&order.SupplierID,
		&order.SupplierUUID,
		&order.OrderNumber,
		&order.Status,
		&order.OrderedAt,
		&order.ExpectedAt,
		&order.Notes,
		&order.CreatedAt,
		&order.UpdatedAt,
		&order.DeletedAt,
	)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return PurchaseOrder{}, service.ErrNotFound
		}
		return PurchaseOrder{}, fmt.Errorf("getting purchase order: %w", err)
	}

	return order, nil
}

func (c *Client) GetPurchaseOrderByUUID(ctx context.Context, orderUUID string) (PurchaseOrder, error) {
	var order PurchaseOrder
	err := c.db.QueryRow(ctx, `
		SELECT po.id, po.uuid, po.supplier_id, s.uuid, po.order_number, po.status, po.ordered_at, po.expected_at, po.notes, po.created_at, po.updated_at, po.deleted_at
		FROM purchase_order po
		JOIN supplier s ON s.id = po.supplier_id
		WHERE po.uuid = $1 AND po.deleted_at IS NULL`,
		orderUUID,
	).Scan(
		&order.ID,
		&order.UUID,
		&order.SupplierID,
		&order.SupplierUUID,
		&order.OrderNumber,
		&order.Status,
		&order.OrderedAt,
		&order.ExpectedAt,
		&order.Notes,
		&order.CreatedAt,
		&order.UpdatedAt,
		&order.DeletedAt,
	)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return PurchaseOrder{}, service.ErrNotFound
		}
		return PurchaseOrder{}, fmt.Errorf("getting purchase order by uuid: %w", err)
	}

	return order, nil
}

func (c *Client) ListPurchaseOrders(ctx context.Context) ([]PurchaseOrder, error) {
	rows, err := c.db.Query(ctx, `
		SELECT po.id, po.uuid, po.supplier_id, s.uuid, po.order_number, po.status, po.ordered_at, po.expected_at, po.notes, po.created_at, po.updated_at, po.deleted_at
		FROM purchase_order po
		JOIN supplier s ON s.id = po.supplier_id
		WHERE po.deleted_at IS NULL
		ORDER BY po.created_at DESC`,
	)
	if err != nil {
		return nil, fmt.Errorf("listing purchase orders: %w", err)
	}
	defer rows.Close()

	var orders []PurchaseOrder
	for rows.Next() {
		var order PurchaseOrder
		if err := rows.Scan(
			&order.ID,
			&order.UUID,
			&order.SupplierID,
			&order.SupplierUUID,
			&order.OrderNumber,
			&order.Status,
			&order.OrderedAt,
			&order.ExpectedAt,
			&order.Notes,
			&order.CreatedAt,
			&order.UpdatedAt,
			&order.DeletedAt,
		); err != nil {
			return nil, fmt.Errorf("scanning purchase order: %w", err)
		}
		orders = append(orders, order)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("listing purchase orders: %w", err)
	}

	return orders, nil
}

func (c *Client) ListPurchaseOrdersBySupplierUUID(ctx context.Context, supplierUUID string) ([]PurchaseOrder, error) {
	rows, err := c.db.Query(ctx, `
		SELECT po.id, po.uuid, po.supplier_id, s.uuid, po.order_number, po.status, po.ordered_at, po.expected_at, po.notes, po.created_at, po.updated_at, po.deleted_at
		FROM purchase_order po
		JOIN supplier s ON s.id = po.supplier_id
		WHERE s.uuid = $1 AND po.deleted_at IS NULL
		ORDER BY po.created_at DESC`,
		supplierUUID,
	)
	if err != nil {
		return nil, fmt.Errorf("listing purchase orders by supplier uuid: %w", err)
	}
	defer rows.Close()

	var orders []PurchaseOrder
	for rows.Next() {
		var order PurchaseOrder
		if err := rows.Scan(
			&order.ID,
			&order.UUID,
			&order.SupplierID,
			&order.SupplierUUID,
			&order.OrderNumber,
			&order.Status,
			&order.OrderedAt,
			&order.ExpectedAt,
			&order.Notes,
			&order.CreatedAt,
			&order.UpdatedAt,
			&order.DeletedAt,
		); err != nil {
			return nil, fmt.Errorf("scanning purchase order: %w", err)
		}
		orders = append(orders, order)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("listing purchase orders by supplier uuid: %w", err)
	}

	return orders, nil
}
